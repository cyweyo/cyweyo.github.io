<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>최영웅 - 프론트엔드 개발자 포트폴리오</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="style.css" />
  </head>

  <body>
    <header>
      <div class="container header-content">
        <h1>최영웅</h1>
        <p class="subtitle">프론트엔드 개발자</p>
        <ul class="contact-info">
          <li><strong>Phone:</strong> 010-9497-1021</li>
          <li><strong>Email:</strong> cyw7715@gmail.com</li>
          <li>
            <strong>Blog:</strong>
            <a href="https://velog.io/@overslept" target="_blank">
              velog.io/@overslept</a
            >
          </li>
          <li>
            <strong>Github:</strong>
            <a href="https://github.com/cyweyo" target="_blank"
              >github.com/cyweyo</a
            >
          </li>
        </ul>
      </div>
    </header>

    <div class="container">
      <div class="insight">
        <h2>💻 소개</h2>
        <div class="insight">
          <div class="insight-body">
            <ul>
              <li>
                <div class="intro-block">
                  <p class="intro-identity">
                    <strong>기능보다 개념에 질문합니다</strong>
                  </p>
                  <p>
                    React 훅을 사용할 때, 작동만 보는 게 아니라
                    <strong>내부 동작 원리를 먼저 파악</strong>합니다. 이해되지
                    않는 코드는 직접 실험하면서 원인을 분석합니다.
                  </p>
                </div>
              </li>

              <li>
                <div class="intro-block">
                  <p class="intro-identity">
                    <strong>기존 방식에 의문을 가집니다</strong>
                  </p>
                  <p>
                    불필요하게 <strong>복잡한 구조나 반복된 상태 관리</strong>가
                    보이면, 더 단순하고 효율적인 구조로 개선할 수 있는 방법을
                    고민합니다.
                  </p>
                </div>
              </li>

              <li>
                <div class="intro-block">
                  <p class="intro-identity">
                    <strong>작동보다 흐름을 중시합니다</strong>
                  </p>
                  <p>
                    기능 단위 구현보다,
                    <strong>사용자가 실제로 겪는 흐름</strong>에 따라 자연스럽게
                    느껴지는 UX 중심으로 페이지를 설계합니다.
                  </p>
                </div>
              </li>
            </ul>
          </div>
        </div>
      </div>

      <section class="project-section">
        <div class="project">
          <h2>🚀 프로젝트 1.</h2>
          <div class="insight">
            <div class="insight-title">
              <h3>
                <a href="https://linkrew.com" target="_blank">Linkrew</a>
              </h3>
            </div>

            <div class="insight-body">
              <p><strong>기간:</strong> 2025.04 ~ 2025.07</p>
              <p>
                <strong>기술 스택:</strong> React, TypeScript, Zustand, Axios,
                TanStack Query, TailwindCSS
              </p>
              <p>
                <strong>유형:</strong> 웹페이지 저장 및 공유 서비스 (팀
                프로젝트, FE 2 / BE 2 / 디자이너 1)
              </p>

              <p style="margin-top: 16px">
                기억하고 다시 보고 싶은 웹사이트 링크들을 저장하고, 다른
                사용자와 <strong>손쉽게 공유</strong>할 수 있는 웹 서비스입니다.
                <br />링크를 저장하면 Open Graph 메타 태그를 분석하여
                <strong>대표 이미지, 파비콘, 제공자명</strong> 등의 정보를
                자동으로 추출하고, 이를 통해 사용자가 링크 내용을
                <strong>더 직관적으로 인식할 수 있도록 구성</strong>했습니다.
              </p>
            </div>
          </div>

          <div class="insight">
            <div class="insight-title">기술 스택 및 선택 이유</div>
            <div class="insight-body">
              <ul>
                <li>
                  <strong>React:</strong> 컴포넌트 기반 SPA 구조로 구현하여,
                  폴더/링크 탐색이나 공유 등 화면 변경을
                  <strong>페이지 리로딩 없이 유연하게 처리</strong>할 수 있어
                  도입했습니다.
                </li>
                <li>
                  <strong>TypeScript:</strong> API 요청/응답 구조를
                  <strong>정적으로 명확히 정의</strong>하고,
                  <strong>컴파일 타임에서 오류를 사전 방지</strong>할 수 있어
                  코드 안정성과 유지보수성을 높이기 위해 도입했습니다.
                </li>

                <li>
                  <strong>Zustand:</strong> Redux에 비해
                  <strong>보일러플레이트 코드가 적고</strong>, 전역 상태를
                  <strong>props 없이 간결하게 접근</strong>할 수 있어, 컴포넌트
                  간 상태 공유가 필요한 구조에서 유리하다고 판단해 선택했습니다.
                </li>

                <li>
                  <strong>TanStack Query:</strong> 서버 상태를 캐싱하고,
                  <strong>mutation 이후 자동 갱신</strong>이 가능해 REST API
                  환경에서 효율적인 데이터 동기화가 가능하다고 판단해
                  도입했습니다.
                </li>

                <li>
                  <strong>Axios:</strong> 인증이 필요한 REST API 환경에서,
                  <strong>인터셉터를 통한 토큰 처리와 에러 핸들링</strong>이
                  용이하고, <strong>요청/응답 로직의 모듈화</strong>에 유리해
                  도입했습니다.
                </li>

                <li>
                  <strong>TailwindCSS:</strong> 유틸리티 클래스 기반으로 빠르게
                  스타일을 적용하고,
                  <strong
                    >일관된 디자인 시스템과 반응형 UI를 효율적으로 구현</strong
                  >할 수 있으며,
                  <strong
                    >사용된 클래스만 포함되는 빌드 구조로 최종 번들 크기도 작게
                    유지</strong
                  >할 수 있어 선택했습니다.
                </li>
              </ul>
            </div>
          </div>

          <div class="insight">
            <div class="insight-title">역할</div>
            <div class="insight-body">
              <ul>
                <li>
                  <strong>폴더/링크 기능 개발:</strong> 폴더와 링크의 생성,
                  수정, 삭제 기능을 구현하고, 클라이언트 상태와 서버 데이터를
                  분리하여 효율적으로 관리했습니다.
                </li>

                <li>
                  <strong>실시간 알림 구현:</strong> 공유 및 초대 요청을 즉시
                  받을 수 있는 실시간 알림 기능을 구현했습니다.
                </li>

                <li>
                  <strong>자동 로그인 유지:</strong> 토큰 만료 시 자동으로
                  갱신하는 인증 흐름을 구현해, 로그인 상태를 끊김 없이
                  유지하도록 처리했습니다.
                </li>

                <li>
                  <strong>회원 관리 기능:</strong> 회원가입, 로그인, 로그아웃,
                  프로필 수정 기능을 역할별로 구조화하여 유지보수와 확장에
                  용이하도록 설계했습니다.
                </li>
              </ul>
            </div>
          </div>

          <div class="insight">
            <div class="insight-title">주요 개발 성과</div>
            <div class="insight-body">
              <ul>
                <li>
                  <strong>링크별 대표 이미지 제공:</strong> YouTube, 블로그 등
                  다양한 콘텐츠 유형의 OG 태그를 활용해
                  <strong>사용자가 링크 내용을 직관적으로 인지</strong>할 수
                  있도록 개선했습니다.
                </li>
                <li>
                  <strong>SSE 알림 시스템 구축:</strong> 백엔드와 직접 연결 및
                  파싱 처리하여,
                  <strong>공유·초대 등의 이벤트를 실시간으로 UI에 </strong
                  >반영했습니다.
                </li>
                <li>
                  <strong>웹 서비스 아키텍처에 대한 실전 경험 축적:</strong>
                  상태 관리, 인증 흐름, 컴포넌트 설계를 직접 구현하며
                  <strong>확장성과 재사용성을 고려한 개발 역량 강화</strong
                  >했습니다.
                </li>
              </ul>
            </div>
          </div>

          <h2>🚧 Trouble Shooting</h2>
          <div class="troubleshooting-card">
            <div class="ts-item">
              <div class="ts-icon">🛠️</div>
              <div>
                <div class="ts-label">문제</div>
                <div class="ts-content">
                  실시간 알림 기능과 일부 API 요청에서 CORS 관련 문제가
                  발생했습니다. <br />특히
                  <strong>EventSource를 활용한 SSE 연결 시</strong> 요청이
                  차단되었고, <strong>PATCH 요청만 CORS 오류로 실패</strong>하는
                  현상도 있었습니다.
                </div>
              </div>
            </div>

            <div class="ts-item">
              <div class="ts-icon">💡</div>
              <div>
                <div class="ts-label">해결</div>
                <div class="ts-content">
                  SSE는 브라우저가
                  <strong>프록시가 아닌 실제 서버로 직접 연결</strong>하는
                  구조였고, 이로 인해 CORS 충돌이 발생했습니다. 알림 요청을
                  <strong>실제 백엔드 도메인으로 연결</strong>하고, 백엔드에
                  <code>Access-Control-Allow-Origin</code> 등 관련 헤더를 설정해
                  문제를 해결했습니다.

                  <br /><br />

                  PATCH 요청의 경우, 브라우저가
                  <strong>Preflight 요청(OPTIONS)</strong>을 자동 전송하는
                  구조임을 확인했고, 백엔드에서
                  <code>Access-Control-Allow-Methods</code>,
                  <code>Access-Control-Allow-Headers</code> 응답이 누락된 것을
                  발견했습니다. 이에 필요한 헤더를 백엔드에 전달하고 수정
                  요청하여 <strong>PATCH 요청도 안정적으로 처리</strong>되도록
                  했습니다.
                </div>
              </div>
            </div>

            <div class="ts-item">
              <div class="ts-icon">✅</div>
              <div>
                <div class="ts-label">성과</div>
                <div class="ts-content">
                  다양한 HTTP 요청과 SSE 연결에서 CORS 이슈가 해결되어,
                  <strong
                    >실시간 알림 기능과 모든 API 요청이 안정적으로 동작</strong
                  >하게 되었습니다.
                </div>
              </div>
            </div>

            <div class="challenge-result">
              <img
                class="added-image"
                src="./image/CorsError.png"
                alt="Cors Error 해결"
              />
            </div>
          </div>

          <div class="troubleshooting-card">
            <div class="ts-item">
              <div class="ts-icon">🛠️</div>
              <div>
                <div class="ts-label">문제</div>
                <div class="ts-content">
                  로그인 상태가 일정 시간 후 만료되면서, 사용자 경험이 끊기는
                  문제
                </div>
              </div>
            </div>
            <div class="ts-item">
              <div class="ts-icon">💡</div>
              <div>
                <div class="ts-label">해결</div>
                <div class="ts-content">
                  AccessToken이 만료된 경우, 사용자는 로그인을 다시 해야 하는
                  불편이 있었습니다. 이를 해결하기 위해 RefreshToken을 이용한
                  자동 토큰 갱신 흐름을 설계했고, 토큰이 만료될 경우 전용 리이슈
                  페이지로 유도한 뒤, 새 토큰을 발급받아 자동으로 다시 로그인
                  상태로 전환되도록 구현했습니다. 이 과정을 사용자에게 노출되지
                  않게 구성하여 UX를 유지했습니다.
                </div>
              </div>
            </div>
            <div class="ts-item">
              <div class="ts-icon">✅</div>
              <div>
                <div class="ts-label">성과</div>
                <div class="ts-content">
                  로그아웃 없이 인증을 유지할 수 있어, 사용자 입장에서 끊김 없는
                  경험을 제공함
                </div>
              </div>
            </div>

            <div class="challenge-result">
              <img
                class="added-image"
                src="./image/refreshToken2.png"
                alt="리프레쉬 토큰 인증 흐름"
              />
            </div>
          </div>

          <h2>🌱 프로젝트를 통해 얻은 점</h2>

          <div class="insight">
            <div class="insight-title">
              웹 서비스 아키텍처에 대한 실전 감각 향상
            </div>
            <div class="insight-body">
              상태 관리, 캐싱, API 통신, 인증 처리 등 프론트엔드의 주요 레이어
              간 역할과 상호작용을 직접 구현하며 체득함.<br />
              <span class="insight-example"
                >TanStack Query로 캐시 관리, Zustand로 전역 상태 공유, Axios
                인터셉터 기반 인증 처리</span
              >
            </div>
          </div>

          <div class="insight">
            <div class="insight-title">
              확장성과 유지보수를 고려한 설계 경험 축적
            </div>
            <div class="insight-body">
              컴포넌트 책임 분리, 상태 범위 조절, 반복 로직 추출 등 재사용성과
              일관성을 고려한 개발 습관을 형성함.<br />
              <span class="insight-example"
                >공통 UI 컴포넌트 분리, props 전달 최소화를 위한 상위 구조
                개선</span
              >
            </div>
          </div>

          <div class="insight">
            <div class="insight-title">코드 리딩 및 협업 역량 향상</div>
            <div class="insight-body">
              팀원이 작성한 구조와 패턴을 빠르게 이해하고 기능 개발에 적용하며,
              협업 과정에서의 의사소통과 코드 이해력이 크게 향상되었습니다.
            </div>
          </div>
        </div>
      </section>

      <section class="project-section">
        <div class="project">
          <h2>🚀 프로젝트 2.</h2>
          <div class="insight">
            <div class="insight-title">
              <h3>
                <a
                  href="https://component-factory-cf4k.vercel.app/"
                  target="_blank"
                  rel="noopener noreferrer"
                  >Component Factory
                </a>
              </h3>
            </div>
            <div class="insight-body">
              <p><strong>기간:</strong> 2024.08.05 ~ 2024.09.20</p>
              <p>
                <strong>기술 스택:</strong> Next.js, Typescript, Zustand,
                TailwindCSS
              </p>
              <p>
                <strong>유형:</strong> 심플하고 일관된 디자인의 다양한 UI
                컴포넌트를 제공하는 라이브러리 (팀 프로젝트, FE: 4)
                <br />
              </p>

              <p style="margin-top: 16px">
                <strong
                  >사용자가 직접 코드를 입력해 사용 방법을 실시간으로
                  확인</strong
                >하고, <strong>props를 통해 자유롭게 커스터마이징</strong>할 수
                있는 컴포넌트 라이브러리
              </p>
            </div>
          </div>

          <div class="insight">
            <div class="insight-title">기술 스택 및 선택 이유</div>
            <div class="insight-body">
              <ul>
                <li>
                  <strong>Next.js:</strong> 페이지 기반 라우팅과 정적 사이트
                  생성을 통해, 각 UI 컴포넌트의 데모 페이지를 손쉽게 구성하고,
                  <strong
                    >HTML 형태로 빌드해 정적 웹사이트로 간편하게 배포</strong
                  >할 수 있어 도입했습니다.
                </li>
                <li>
                  <strong>TypeScript:</strong> 다양한 props 구조를 갖는 UI
                  컴포넌트를 설계하면서,
                  <strong>타입 기반의 안정성과 자동완성 지원</strong>을 통해
                  생산성과 유지보수성을 높였습니다.
                </li>
                <li>
                  <strong>Zustand:</strong> Dropdown처럼 분리된 컴포넌트 간
                  상태를 공유하기 위해,
                  <strong>간결한 전역 상태 관리와 낮은 러닝커브</strong>를 가진
                  Zustand를 사용했습니다.
                </li>
              </ul>
            </div>
          </div>

          <div class="insight">
            <div class="insight-title">역할</div>
            <div class="insight-body">
              <ul>
                <li>
                  주요 UI 컴포넌트(Alert, Breadcrumb, Dropdown 등) 개발 및
                  최적화
                </li>
                <li>
                  Babel과 react-simple-code-editor를 활용해 사용자가 직접
                  컴포넌트 코드를 수정하면
                  <strong>즉시 결과가 반영되는 실시간 렌더링 기능</strong> 구현
                </li>
                <li>
                  <strong>컴포넌트 구조 개선 및 코드 리팩토링</strong>을 통해
                  재사용성, 유지보수성, 성능, 확장성 향상
                </li>
              </ul>
            </div>
          </div>

          <div class="insight">
            <div class="insight-title">주요 개발 성과</div>
            <ol>
              <li>
                <strong>컴포넌트 설계 및 개발</strong>
                <ul>
                  <li>
                    Alert, Breadcrumb, Dropdown 등 다양한 UI 컴포넌트를 설계 및
                    개발하여 <strong>재사용성과 일관성</strong> 확보
                  </li>
                  <li>
                    props 기반 사용자 정의 속성 설계로
                    <strong>유연한 스타일링 시스템</strong> 제공
                  </li>
                </ul>
              </li>

              <li>
                <strong>실시간 렌더링 시스템 구현</strong>
                <ul>
                  <li>
                    <strong>react-simple-code-editor + Babel</strong>을 활용하여
                    코드 입력 → 실시간 렌더링 흐름 구현
                  </li>
                  <li>
                    Live Preview 기능으로 개발자가
                    <strong>바로 피드백 받으며 학습 가능</strong>한 구조 설계
                  </li>
                  <li>
                    다양한 화면 크기에서
                    <strong>컴포넌트 동작 테스트 가능한 환경 구축</strong>
                  </li>
                </ul>

                <div class="challenge-result">
                  <strong>실시간 렌더링 시스템 데모:</strong>
                </div>
                <video class="demo-video" controls loop muted width="100%">
                  <source
                    src="./video/realtimeRendering.mov"
                    type="video/mp4"
                  />
                  브라우저가 동영상 태그를 지원하지 않습니다.
                </video>
              </li>

              <li>
                <strong>사용자 경험 및 성능 최적화</strong>
                <ul>
                  <li>
                    로딩 UX 개선을 위한
                    <strong>Skeleton 컴포넌트</strong> 도입으로 체감 대기 시간
                    감소
                  </li>
                  <li>
                    지연 로딩, 코드 스플리팅으로
                    <strong>초기 로딩 시간 약 30% 단축</strong>
                  </li>
                  <li>
                    트리 쉐이킹 및 동적 임포트로
                    <strong>번들 크기 최소화</strong>, 모바일 성능 향상
                  </li>
                  <li>
                    Unsplash API 이미지에
                    <strong>캐싱 및 최적화 처리</strong> 적용하여 데이터 사용량
                    절감
                  </li>
                </ul>
              </li>
            </ol>
          </div>

          <h2>🚧 Trouble Shooting</h2>

          <div class="troubleshooting-card">
            <div class="ts-item">
              <div class="ts-icon">🛠️</div>
              <div>
                <div class="ts-label">문제</div>
                <div class="ts-content">
                  사용자가 UI 컴포넌트 라이브러리를 학습할 때, 문서만 읽어서는
                  실제 사용 방법을 이해하기 어렵고, 컴포넌트 사용법을
                  실험해보려면 개발 환경을 직접 세팅해야 하는 불편함이
                  있었습니다
                </div>
              </div>
            </div>

            <div class="ts-item">
              <div class="ts-icon">💡</div>
              <div>
                <div class="ts-label">해결</div>
                <div class="ts-content">
                  Babel Standalone과 react-simple-code-editor를 활용하여
                  웹사이트 내에서 컴포넌트 코드를 직접 수정하고 그 결과를
                  실시간으로 확인할 수 있는 대화형 시스템 개발. 변환 엔진이 JSX
                  코드를 자동으로 해석해 실시간 미리보기를 제공합니다
                </div>
              </div>
            </div>

            <div class="ts-item">
              <div class="ts-icon">✅</div>
              <div>
                <div class="ts-label">성과:</div>
                <div class="ts-content">
                  사용자가 코드를 직접 수정하고 즉시 결과를 확인하며 실험할 수
                  있어 학습 곡선이 크게 완화되었고, "수정해보며 배우는" 직관적인
                  경험을 통해 컴포넌트 라이브러리 도입 장벽을 효과적으로
                  낮췄습니다
                </div>
              </div>
            </div>

            <div class="ts-item">
              <div class="challenge-result">
                <strong>실시간 렌더링 시스템 구조:</strong>
                <image
                  class="added-image"
                  src="./image/renderingSystem.png"
                ></image>
              </div>
            </div>
          </div>

          <div class="troubleshooting-card">
            <div class="ts-item">
              <div class="ts-icon">🛠️</div>
              <div>
                <div class="ts-label">문제</div>
                <div class="ts-content">
                  다양한 디자인 시스템과 UI 요구사항을 모두 만족시킬 수 있도록,
                  <strong
                    >재사용 가능하면서도 유연한 컴포넌트를 설계하는 데
                    어려움</strong
                  >이 있었습니다.
                </div>
              </div>
            </div>

            <div class="ts-item">
              <div class="ts-icon">💡</div>
              <div>
                <div class="ts-label">해결</div>
                <div class="ts-content">
                  공통된 컴포넌트 구조를 바탕으로
                  <strong>Composition Pattern</strong>을 적용하고, 다양한
                  스타일과 동작을 조정할 수 있도록
                  <strong>Props 확장성을 고려한 API</strong>를 설계했습니다.
                </div>
              </div>
            </div>

            <div class="ts-item">
              <div class="ts-icon">✅</div>
              <div>
                <div class="ts-label">성과</div>
                <div class="ts-content">
                  하나의 컴포넌트로도
                  <strong>다양한 UI 상황에 쉽게 대응</strong>할 수 있게 되었고,
                  팀 전체에서 <strong>재사용성과 유지보수성</strong>이 높은
                  컴포넌트 라이브러리를 구축할 수 있었습니다.
                </div>
              </div>
            </div>

            <div class="ts-item">
              <div class="ts-icon">🖼️</div>
              <div>
                <div class="ts-label">컴포넌트 합성 패턴 예시</div>
                <div class="ts-content">
                  <img
                    class="added-image"
                    src="./image/composition-pattern.png"
                    alt="컴포넌트 합성 패턴 예시"
                  />
                </div>
              </div>
            </div>
          </div>

          <div class="troubleshooting-card">
            <div class="ts-item">
              <div class="ts-icon">🛠️</div>
              <div>
                <div class="ts-label">문제</div>
                <div class="ts-content">
                  DropdownMenu 컴포넌트에서 Trigger(메뉴를 여는 버튼)와
                  Content(메뉴 내용)가 서로 다른 컴포넌트로 분리되어 있어 상태를
                  공유하기 어려움
                </div>
              </div>
            </div>

            <div class="ts-item">
              <div class="ts-icon">💡</div>
              <div>
                <div class="ts-label">해결</div>
                <div class="ts-content">
                  Zustand 상태 관리 라이브러리를 도입하여 Trigger와 Content 간의
                  상태를 중앙에서 관리하도록 구현, 복잡한 props drilling 없이 각
                  컴포넌트에서 직접 상태에 접근 가능하게 함
                </div>
              </div>
            </div>

            <div class="ts-item">
              <div class="ts-icon">✅</div>
              <div>
                <div class="ts-label">성과</div>
                <div class="ts-content">
                  컴포넌트 간 상태 공유가 원활해지고, 불필요한 리렌더링 방지로
                  성능 향상, 코드 가독성과 유지보수성 개선
                </div>
              </div>
            </div>

            <div class="challenge-result">
              <strong>Zustand 상태 관리 패턴:</strong>
              <image
                class="added-image"
                src="./image/zustand-state-management.png"
              />
            </div>
          </div>
        </div>
      </section>

      <section>
        <h2 class="intro-header">기술 스택</h2>

        <div class="skills-section">
          <div class="skill-category">
            <h3>Language</h3>
            <ul>
              <li>JavaScript</li>
              <li>TypeScript</li>
            </ul>
          </div>

          <div class="skill-category">
            <h3>FrameWork & Library</h3>
            <ul>
              <li>React</li>
              <li>Next.js</li>
              <li>TanStack Query</li>
              <li>Zustand</li>
              <li>TailwindCSS</li>
              <li>Styled Components</li>
            </ul>
          </div>

          <div class="skill-category">
            <h3>Tool</h3>
            <ul>
              <li>Git</li>
              <li>VS Code</li>
              <li>Figma</li>
              <li>Postman</li>
              <li>AWS EC2</li>
              <li>Docker</li>
            </ul>
          </div>

          <div class="skill-category">
            <h3>etc</h3>
            <ul>
              <li>RESTful API 연동</li>
              <li>UI 컴포넌트 설계</li>
              <li>모바일 UI/UX 최적화</li>
              <li>반응형 디자인</li>
            </ul>
          </div>
        </div>
      </section>

      <section>
        <h2 class="intro-header">교육</h2>
        <div class="education">
          <ul>
            <li>
              프론트엔드 프로젝트 캠프 : Next.js 2기 (2024.07.15 ~ 2024.08.02)
            </li>
          </ul>
        </div>
      </section>
    </div>
  </body>
</html>
